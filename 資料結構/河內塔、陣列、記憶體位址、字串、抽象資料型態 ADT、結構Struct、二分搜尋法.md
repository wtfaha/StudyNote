# 資料結構
*****
# 河內塔、陣列、記憶體位址、字串、抽象資料型態 ADT、結構Struct、二分搜尋法

+ ### 河內塔  
	有3根直立的木棒(A, B, C)，最左邊的木棒(A)有n個由小到大的盤子  
	將全部盤子由最左邊的棒子移到最右邊(A → C)  
  	一次只能移動一個盤子  
  	較大的盤子不能放在較小的盤子上面 ⇒ 只能移動最上面的盤子  
	
	解法  
	```
	把問題分成數個步驟，每步驟的目的皆為將還沒移到目的地的盤子中最大的盤子移到目的地
	3根木棒可視為：出發點、輔助移動、目的地
	先將非最大的盤子移到輔助的木棒，再將最大盤子移到目的地，再將剩餘的盤子移到目的地
	```
  	
	**若盤子為n個 ⇒ 需移動![equation](http://latex.codecogs.com/gif.latex?2^{n}-1)次**  
	
	設計遞迴
	```
  	Base Case： if n = 1 ⇒ 直接由來源木棒移到目的木棒
  	General Case：
  	將n-1盤子 ⇒ 由來源木棒(A)移到輔助木棒(B)
  	將最大盤子 ⇒ 由來源木棒(A)移到目的木棒(C)
  	將還沒到目的盤子中最大者 ⇒ 由新的來源木棒(B)透過新的輔助木棒(A)移到目的木棒(C)	
  	```
  	演算法(JAVA)  
	```
  	void Towers(int Disk, char Src, char Dest, char Aux)
  	{
		if(Disk == 1)
			System.out.println("移動盤子" + Disk + "由" + Src + "到" + Dest);
		else
		{
			//先將較小的盤子移到輔助木棒
			Towers( Disk - 1, Src, Aux, Dest);

			//移最大的盤子到目的
			System.out.println("移動盤子" + Disk + "由" + Src + "到" + Dest);

			//將較小的盤子移到目的
			Towers(  Disk - 1, Aux, Dest, Src);
		}
  	}
	```
	
+ ### 陣列  
	陣列想成一種物件，然後陣列裡面可以放陣列就好了，放幾個都不是問題  
	
+ ### 記憶體位址  
	當你宣告一個8格的整數陣列時，其實程式向作業系統要求了 32bytes 的連續空間(通常一個 int 佔 4bytes，八個就佔 32bytes)。  
	![](https://img.noob.tw//2016/11/array1.png)  
	(圖中一格為 1byte，記憶體位址以 10 進位表示。)  
	
	**&可以用來取得記憶體位址  
	\*可以用來取值**  
	
	如果想要取得 arr[0] 的記憶體位址，可以用 &arr[0] 來取得。  
	```
	&arr[0] 會得到 1000。  
	&arr[1] 會得到 1004
	&arr[2] 會得到 1008。  
	```
	**陣列的底層其實是用指標來實作**  
	可以透過 \*(arr) 來取得陣列的第一格、*(arr+1) 來取得陣列的第二格。  
	
	ex1 :   
	```
	Q : C語言中，宣告 int a[3] = {2, 1, 6}，若 &a[0] 的值是 1000 且整數之大小為 4 位元組，請問 *(a+2) 的值為合？
	
	A : * 是用來取值的，所以 *(a+2) 可以看成 a[2]，也就是 a 的第三格，答案為 6
	```
	
	ex2 :  
	```
	Q : 假設 a 為一大小 m×n 之二維陣列，其中 a[2][2] 之位址為 121，a[5][4] 之位址為 194
	已知每一元素之大小為 1 位元組，則 a[3][5] 之位址為合？
	(假設陣列索引值由 0 開始、記憶體位址以 10 進位表示)
	
	A : 227
	
	這題就比較複雜一點，把它想成一個 m×n 之表格，其中透過一個整數為 4bytes 的觀念，可推得：

	a[2][2] 的記憶體位址為 121 → 可推得 a[2][0] 的記憶體位址為 119
	a[5][4] 的記憶體位址為 194 → 可推得 a[5][0] 的記憶體位址為 190
	假設 a[0][0] 的記憶體為 k，則可以列出：

	k+2n = 119
	k+5n = 190
	解出來發現 k 和 n 沒有正整數解。

	由於陣列有可能以列為主，也有可能以行為主，我們只好轉過來推得：

	a[2][2] 的記憶體位址為 121 → 可推得 a[0][2] 的記憶體位址為 119
	a[5][4] 的記憶體位址為 194 → 可推得 a[0][4] 的記憶體位址為 189
	假設 a[0][0] 的記憶體位址為 k ，則可以列出：

	k+2m = 119
	k+4m = 189
	解出得 k+5m+3 = 227
	```
+ ### 字串  
	C 語言裡面沒有字串，字串其實是由字元陣列組成的
	```
	char name[] = "NoobTW";
	```
	**字串需要一個 ‘\0’ 符號做結尾**，來判斷這個字串已經結束了  
	![](https://img.noob.tw//2016/11/array2.png)  
	
+ ### 抽象資料型態 ADT  
	**只定義數學觀念**，將資料和操作一起思考的觀念。  
	這種資料型態著重於資料的運算，**並不考慮實作時的細節或資料本身的性質**。
	
	ex : 正整數的 ADT
	```
	物件定義：正整數是指從零開始一直到 INT_MAX 的有順序整數。

	方法定義：
		Zero()：即整數 0
		Equal(x, y)：整數 x 和整數 y 是否相等。
		Add(x, y)：把整數 x 和整數 y 相加(在不超過 INT_MAX 的情況下)。
		Sub(x, y)：拿整數 x 減掉整數 y (在不小於零的情況下)。
	```
	寫 ADT 時沒有特別的規範，只需要將概念清楚表達出來即可

+ ### 結構 Struct  
	struct 是 C 語言的結構  
	```
	struct 結構名稱{
	    資料型態 變數名稱;
	};
	```
	ex : 定義一個學生的資料  
	```
	struct Student{
	    char name[10];
	    int age;
	    int gender;
	    char studentid[10];
	    char dept[10];
	};
	struct Student Noob; // 宣告一個學生 Noob
	```
	typedef 可以用來為資料型態或自訂的結構建立別名  
	```
	typedef Student stu;
	stu Noob;
	```

+ ### 二分搜尋法  
	類似終極密碼，想要快速的把遊戲玩完，方法就是一直喊中間的數：50、25、38、44、46、48、49、BOOM！  
	
	適用於已經由小排到大的數列。  
	每次都從數列的中間開始搜尋，如果中間這個數大於我們所要找的目標數，那就往左邊找；  
	反之，再往右邊找。每次都可以把數列砍半，是很有效率的方式  
	
	最快的情況下，若一次就找到，所需次數是 1。  
	若最慢的情況下，需要花多少時間呢？  
	假設我們花了 x 次才找到，也就是說 1 = N/2<sup>x</sup>。  
	
	假設有4個數，花2次就可以找到
	s如果有8個數，花3次就可以找到
	**所以如果有n個數，只要2<sup>x</sup> > n 就可以找到了**  
	2<sup>x</sup> = N
	log<sub>2</sub>(2<sup>x</sup>) = log<sub>2</sub>N  
	x * log<sub>2</sub>2 = log<sub>2</sub>N  
	x\*1 = log<sub>2</sub>N  
	
	最慢的情況下需要花 log<sub>2</sub>N 次才能找到。  
	
+ ### log  
	log<sub>2</sub>N  
	
	ex :  
	log<sub>2</sub>32 = 5  
	2<sup>5</sup> = 32  
	
*****
[河內塔](http://notepad.yehyeh.net/Content/DS/CH02/4.php)  

[資料結構筆記(二)：陣列、字串與指標](https://noob.tw/data-structure-array)  

[資料結構筆記(三)：抽象資料結構(ADT)與Struct](https://noob.tw/data-structure-adt)  
